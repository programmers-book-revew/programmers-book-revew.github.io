---
layout: post
title: RESTful Webサービス
categories: rank_3
tags: [web, oreilly]
---


<div class="book"><div class="book_image"><a href="http://www.amazon.co.jp/dp/4873113539"><img src="/images/restful_web_service.jpg"></img></a></div><div class="book_info">/オライリージャパン</div><div class="clear"></div></div>

「サーバ側のリソースの状態が変化するときは POST を、状態が変化しないときは GET を使う」という下のURLの文章を読んで、自分が全くRESTful(というかHTTP)を理解していないことに気づき衝動買いしたもの。http://blogs.ricollab.jp/webtech/2008/04/introduction_to_rest/ 

自分の理解で言うと、getter(GET, HEAD)とsetter(PUT)とnew(POST, PUT)とside-effect(POST)というオペレーションでオブジェクト指向でHTTPを設計せよという原理なのだと感じた。ここでオブジェクトはURIであり、getterは副作用を与えず、setterはべき等性(1回setしたものとそれ以上setした状態は同じ)を満たす。 

これで実現しようとすると、処理をさせたいもの全てにリソースを与える必要があるため、オブジェクト(URI)の数が膨大になると思う。 

既存のWebサービス技術(SOAP, WSDL, WS-*)をPOST指向のRESTfulの敵と捉え、大Webサービス(Big Web Services)と呼び揶揄している。 

「シンプルに」という理念は良く分かるのだけど、既にかけ離れてしまっている現実においてこの設計思想を原理主義のまま実装するのはかえって手間になると思う。多くのファイアーウォールではPUT, DELETEを通さないだろうし、トランザクションの実装は考えただけでも複雑だ。Railsなどのフレームワークなどの整備があって初めて普及すると思う。GoogleやYahooなどが採用していることからも流れが来ているのは良く分かるのだけど。 

最も大きな魅力はサーバのステートレス化によるスケーラビリティだと感じた。サーバでセッションを管理する必要が無いので、スケールさせるのが容易なのである。(上手く実装すれば)ブラウザの戻るボタンから解放されるのもうれしいだろう。その他は、精神的に気持ちが良い、ということ。HTTPをHTTPとして、URIをURIとして使おうという感覚には共感する。 

以下、自分用メモ<!--more-->

1章 プログラマブルWebとWebサービス 

> * Webサービスアーキテクチャ 
    * RESTfulアーキテクチャでは、メソッド情報はHTTPメソッドに含まれる。リソース指向アーキテクチャでは、スコープ情報はURIに含まれる。(p.14) 
    * XML-RPCでは、どんなサービスを実行しようとURIは常に一定であり、HTTPメソッドは常にPOSTである。RESTfulサービスがスコープ情報のさまざまな値に対して異なるURIを公開するのに対し、RPCスタイルのサービスは一般に、「ドキュメントプロセッサ」ごとにURIを公開する。(p.16) 
    *  REST-RPCハイブリッドアーキテクチャ(著者が考えた造語)の例として、次のFlickr WebサービスのURIを考える。http://www.flickr.com/services/rest?api_key=xxx&method=flickr.phots.search&tags=penguinではRESTfulリソース指向サービスと同様に、URIにスコープ情報(「penguinのタグの付いた画像」)が含まれる。だが、メソッド情報(「画像の検索」)もURIに含まれている。RESTfulサービスでは、メソッド情報はHTTPメソッド(GET)に含まれ、残りはスコープ情報になる。 
* URI 
    * リソース指向のRESTfulサービスは、クライアントが操作できるデータごとにURIを公開する。REST-RPCハイブリッドは、データを取得するためのURI、データを削除するためのURIなど、クライアントが実行できる操作ごとにURIを公開する。RPCスタイルのサービスは、RPCを処理できるプロセスごとにURIを公開する。通常、そうしたURIは1つだけ(サービスのエンドポイント)である。(p.19) 

2章 Webサービスクライアントの作成 

> * JSON 
    * JSONがそれほど単純なら、なぜすべてのことにJSONを使用しないのか。そうすることも可能だが、お勧めしない。JSONはデータ構造全般を表現するのに適しており、Webは主にドキュメントを提供するのに適している。ドキュメントは不規則で自己記述的なデータ構造であり、互いにリンクされている。XMLとHTMLは、ドキュメントを表現することに特化している。配列のXML表現が読みづらいのと同じように、WebページのJSON表現はかなり読みづらい。JSONが役立つのは、ドキュメントパラダイムにうまく適合しないデータ構造(単純なリストやハッシュなど)を定義しなければならない場合である。(p.48) 

4章 リソース指向アーキテクチャ(ROA) 

> * POST 
    * PUTとPOSTの違いは次のとおりである。クライアントは、新しいリソースのURIに送信することが決定できるばあにPUTを使用し、新しいリソースのURIをサーバーが決定する場合にPOSTを使用する。POSTを使用する例として、ブログの新しいエントリの作成がある。/weblogs/myweblog/entries/1になるか/weblogs/myweblog/entries/1000になるかはクライアントが知らないこともしくは知らなくても良いことである。(p.104) 
* 安全性(safety)とべき等性(idempotence) 
    * GETとHEADは(正しく使用すれば)安全であり、GET, HEAD, PUT, DELETEはべき等である。POSTはそのどちらでもない。 
    *  安全性 
サーバの状態を変更するためのものではない。何回繰り返しても同じ結果が得られる。 
    * べき等性 
何回適用しても結果が同じもの(cf. 4x0x0x0と4x0)。逆にリソースの状態を相対的に変更する表現としてPUTを用いてはならない。PUTを使用して、4に設定しても良いが、値を1ずつインクリメントしてはならない。 
    * 安全性とべき等性の重要性 
信頼できないネットワークで、信頼できるHTTPでリクエストを送信できる。返送されなければ、もう一度リクエストを送信すればよい。 

7章 サービスの実装 

> * RESTfulの(Railsでの)実際 
Railsでは通常.../bookmarks/<データベースID>となるがRESTfulでは.../bookmarks/xxx.xxx/と実装したい。しかし、Railsでの実装が難しいため、.../bookmarks/url/<URIのMD5>としている。その説明が「意味不明なデータベースIDよりも、このほうが確かにましである」とのこと。ホントかよ。 

8章 RESTとROAのベストプラクティス 

 > .../myblog/rebuild-indexのようなURIは、そのURIにリンクしても意味はない。このようにURIにメソッド情報を含める代わりに、既存のリソース(.../myweblog)でオーバーロードPOSTをサポートし、入力表現でメソッド情報(method=rebuild-index)を要求すればよい。このようにすれば、統一インターフェイスに完全に準拠しないものの、.../myweblogはリソースのように動作するし、GET, PUT, DELETEに応答し、オーバーロードPOST経由の「rebuild-index」にも応答する。オブジェクト指向の意味では、依然としてオブジェクトである。 
経験則として、オーバーロードPOSTを使用していて、同じURIでGETとPOSTをサポートしないとしたら、おそらくリソースを提供しているのではなく、RPCスタイルのサービスを提供していることになる。(p.229) 

9章 サービスの基本要素 

> POSTでべき等性を実現するためにPOE(POST Once Exactly)という仕組みがある(実装はまだ？)。仕組みは次のとおり。クライアントからのHEADに対しサーバは一回限り有効なURIを独自HtTPヘッダPOE-Linksに埋め込む。一度そのURIにPOSTアクセスが完了するとその後はサーバは405(Method Not Allowed/Operation Not Supported)で応答するようにする。(p.296)
