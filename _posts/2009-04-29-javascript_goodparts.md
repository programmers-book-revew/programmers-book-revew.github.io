---
layout: post
title: JavaScript： The Good Parts
categories: rank_3
tags: [プログラマ, javascript, oreilly]
---


<div class="book"><div class="book_image"><a href="http://www.amazon.co.jp/dp/4873113911"><img src="/images/javascript_goodparts.jpg"></a></div><div class="book_info">Douglas Crockford/オライリージャパン</div><div class="clear"></div></div>

JavaScriptの良い書き方、悪い書き方について著者の熱い情熱で綴っている。見識は深いのだけど、その情熱は、大部分の人は引いてしまう気がする。自分で取捨選択するのが良いと思う。実際、かなりためになった。

その哲学が書かれているだろう、10章の“美しい機能たち”は読んでいて気持ちが良いほど同意できる良い文章だった。余計な機能は不要なだけではなく好ましくない結果を生じさせるマイナスのものだという本書全体を通した強い信念が読み取れる。 

Google Tech Talksで本書の内容をカバーした講演もある(英語)。おもしろい。 
[http://www.youtube.com/watch?v=hQVTIJBZook](http://www.youtube.com/watch?v=hQVTIJBZook) 

メモ 

* コメント 
/* /a*/.match(s) */という場合もあるので//を使った方が良い 
* 数値 
数値型は一つしかなく64bitの浮動小数(Javaのdoubleと同じ)。 
NaNは自分自身も含めてどんな値ともイコールにならない。判定にはisNaNを使う。 
* 文字列 
文字は16bitのユニコード。 
* falseとして判定されるもの 
false, null, undefined, '', 0, NaN 
* グローバル変数を使いたいときは、一つだけ用意して、それをコンテナに使う。 
var MYAPP = {} 
MYAPP.stooge = { .... } 
MYAPP.flight = { .... } 
* 関数をオブジェクトを指定しないで呼ぶと、thisには大域オブジェクトが束縛される(マジカヨ。Javaなどの言語はthisはプログラムが書かれているコンテキストのオブジェクトを指す。) 
* 配列の列挙でfor in文を使うと順序が保証されない。 
* new を使うものは間違いがわかりやすいように最初の文字は大文字で定義。 
* newを使うと、private変数を作れない、継承したオブジェクトのメソッドを呼び出せない。関数型パターンと呼んでいるクロージャを使った方式を使えばこれらは可能(なので、こっちを使った方が良いという主張)。 

感想 

* 配列かどうかの判定を凝った判定ルーチンで実現していた。まさにダックタイピング。 
* メモ化の意味は分からなかった 
メモ化とはクロージャ内の環境に既に計算した値をキャッシュすることだと認識したのだけど、fibやfactなら繰り返しにすれば良いし、n-Queenなどは全ての場合のメモリ領域も必要となるので現実的ではないと思う。
* new 
newを使わない方が良いというのは極端な気がする。プロトタイプ型なのだからクラス型の真似をする必要はないというのは同意するのだけど、既にその世界でイデオムになっているのにそれを覆すのは逆に混乱を起こす気がする。 
* 等価演算子(==)の仕様がイマイチピンと来ない。 
0 == '0'はtrueなのに[1] == [1]はfalseだ。前者は余計とも思える型変換のせいだし、後者はSchemeのequals?(値を評価した結果を比較)やJavaのequals(オブジェクトのhash値などで比較)とは違うという所に起因している。気持ち悪いのは、'' == '0'はfalseだけど、0 =='', 0 == '0'がtrueな所。推移律が通用しない、驚くべき結果。' \t\r\n ' == 0がtrueというのもあった。著者の主張は===を使えということらしい。それで自分でやってしまいそうなのは、object['property'] === nullとか(undefiendが正しい)。 

* continue文 
著者はリファクタリングによりcontinue文を使わないように出来ると言っているが、使うべきところ(使うほうがわかりやすいところ)は使った方が良いと思う。 
* switch 
breakを必ず書くというのは同意。ただ、同じ処理を重複して書きたくないというのもよく分かる。これは、言語側で解決すべき問題(ある処理を終わらせたあと、明示的に他のケースの処理もさせるという文法を作る)だと思っている。 

その他 
「線に沿って作ることができないシーケンスは、すべて文法的に正しくない」の対偶は「文法的に正しいすべての文を線に沿ってシーケンスを作ることができる」(自分で余計なことを考えてこんがらがった)。 

この前書いた落とし穴のパターンがそのまんま書いてあった(p.45)。 

著者の書いたビューティフルコードの章を読み直してみた。JavaScriptでJavaScriptのパーサを書いていた。見た目手続き型で書いたあるからか、なんとなく違和感。再帰バリバリの処理はLispなどの見た目も関数型言語で書きたい。
