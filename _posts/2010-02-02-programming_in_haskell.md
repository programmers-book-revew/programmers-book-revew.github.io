---
layout: post
title: プログラミングHaskell
categories: rank_4
tags: [プログラマ, haskell]
---


<div class="book"><div class="book_image"><a href="http://www.amazon.co.jp/dp/4274067815/"><img src="/images/programming_in_haskell.jpg"></a></div><div class="book_info">Graham Hutton/オーム社</div><div class="clear"></div></div>

Hakellのあこがれは、カテゴリ(圏論)の理解へのあこがれだった。ソフトウェア科学のための論理学(岩波講座)という本でカテゴリを挫折して依頼、いつかは自分も理解したいと思っていた。がんばって理解しようとしてもがいた感覚ではカテゴリとは関数を値とするような世界の記述方法なんだろうって感覚だった。そして、それがHaskellできそうな気がすると思い始めたとき、これを使いこなせればカテゴリも理解しやすくなっているのではないかと淡い期待を抱いた。 

Haskellを知った時期は結構早かった気がする(1998年くらい?)。後輩が研究対象にしていて熱狂的なファンになったのを横目にそのすごさがいまいち分からなかった。遅延評価ってそんなにいいのくらい。使いづらいじゃん、みたいな。で、ブームになりかけた頃に日本語の本が出たので買って読んでみたのだけど、かなりいまいちの本でどうも触手が動かなかった。 
で、気も熟してこの本。薄いのに必要最小限でしっかりと説明している。自分みたいにチョロッと読んで分かった気になりたい人にはありがたい。1日であっと言う間に読んでしまった。当たり前だけどこれでプログラムが書けるようになったわけでは全く無いけど。 

1章から7章までは他の関数型言語を学んだ人ならすんなり入れると思う。そうでない人にも優れた関数型言語の入門書だと思う。そしてモナド、モナドと身構えていると、さらりと書かれていて納得させてくれる。この本当はまったく分かっていないけど分かった気にさせてくれるところがうれしい。遅延評価のところもわかりやすく書かれているし、関数が評価されるということを例えばmultiから*へと自然に教えてくれるのもやさしいと思う。プログラムの検証は普通の本のように論理体系を作ってそこでセコセコとやって最終的にはHaskellの中で検証するのかと思ったのだけど、流石にそこまではやらず、人間が手を動かしながらやっていた。それでも、検証の技術を使って(というか定義をうまく使って)++(append)を削除して効率的なプログラムを作るというのは新鮮だった。 

Schemeをやっていた時に、うまく抽象化できる部分を見つけて悦に浸っていた瞬間を数多く体験できそうな良い言語だと思った。 
普通の言葉で書き直すと、高階関数を使ったプログラミングがしやすいということ。例えば、文字列中の空白を取り除くプログラムを書けと言われた時どうするだろう。自分なら、文字列中の文字を一文字ずつ走査し空白があれば取り除くプログラムを書く。しかし、この本ではさらりと、filter(≠, ' ') "abc def ghi"などと書く。 
もちろんRubyでもJavaでもCでもこのようなプログラムは出来る(FORTRANだって高階関数の機能はある)。でも、できることとそう考えるかということは違う。この辺はプログラミング言語とチューリング完全の議論で腐るほど議論尽くされている。終止符を打つ最終手段は、Paul Grahamの“普通のやつらの上を行け” http://practical-scheme.net/trans/beating-the-averages-j.html 。 

プログラマにとって、実装をどうするかという観点ではなくて、本質はどうなのかということを問われる楽しいプログラミング言語だ。プログラミングが楽しくなれそう。自分の能力が問われる気がする。 
どのプログラミング言語が好きかと聞かれるとSchemeと答えているのだけど、その理由はSchemeでプログラムしていると楽しいから、と抽象的な答えにとどまってしまっていた。たぶん、その理由がこの辺りにあるような気がする。自分が賢くなったと勘違いできる感覚がうれしいのだと思う。 

ちなみにこんなに偉そうな言を書いておいて1行もソースコードをまだ書いてない。ports(snow leopard)でghcとhugs98が簡単に入らないなんて、と言い訳。演習問題をコツコツ解きたい。 

まとめると、プログラムをしたくなる良い本でした。とりあえずHaskellで3 not problem(3個の入力の否定を2つのnotとその他の演算子で実現する問題)を(力ずくで)解く!と宣言して(自分の自意識過剰を当てにして)続きのポインタを無理やり持たせてみる。
