---
layout: post
title: すごいHakell たのしく学ぼう!
categories: rank_4
tags: [プログラマ, haskell]
---


<div class="book"><div class="book_image"><a href="http://www.amazon.co.jp/dp/4274068854"><img src="/images/learn_you_a_haskell.jpg"></img></a></div><div class="book_info">Miran Lipovaca/オーム社</div><div class="clear"></div></div>

Hakellの力強さが理解できるよい本だった。自分が書けるようになるかは自信はないが、少なくても書いてあることは理解した気になれるのでうれしい。
なぜ良い本なのかを挙げてみる。
- 多くの例題を通して実際のコードレベルで理解できる。
- 一つずつステップを区切って説明しているので、理解がしやすい。
- なぜそれがうれしいのかが、その都度書いてあるので、違和感なく、新しい概念を受け入れられる。
- 文章も丁寧に書かれているので理解がすすむ。前に書いたことでも、ページ数を挙げるのではなく、そこで思い出すべきことを書いてくれているので遡る必要がない。結構大事なことだと思う。

Hakellのよさを感じたところとして、本当の関数型指向でプログラミングができると感じた点がある。たとえば、関数合成において、データはひとつであり、それ以外は関数を合成されたもので処理するという考え方をポイントフリースタイルという形で実現できる。
通常の考え方でプログラミングすると、つぎのようにデータありきで、その結果を次の処理に適用することで、計算をすすめていく記述になる。
fn x = ceiling (negate (tan (cos (max 50 x))))
Haskellならば、これを下のように書き換えることができる。
fn = ceiling . negate . tan . cos . max 50
引数はなく、関数に着目され、、それらが関数合成(.)で実現されているのが見て取れる。この考え方でプログラミングできるようになることにあこがれる。

モナドは文脈付きの計算と言うのが、多くの例題を通じて理解できた。

状態が必要なときは、計算結果と状態をペアに持ち、状態を更新しながら計算を進めていくところに、関数型言語の限界を感じた。例えば、Zipなどで木を進んで行くときに、今まで進んだ木、残りの木、今いる場所のペアで管理していて、新たに進む毎にペアを一部作りなおす(Consセルが一つ生成される)ところが、ポインタ操作だけですむ言語とは異なる。
さすがは、カシコイ人が集まって作った言語だけあって、きれいに抽象化されていると感じる。失敗(例外)をモナドに持ち込むことで、計算結果ときれいに分離している。また、同じような所があれば、リスト、木構造などなど、それらの共通項から抽象化された、ファンクター、モナドなどなどに引き上げられている。

